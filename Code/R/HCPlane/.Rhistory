distributions[,i] = distribution(series[,i], dimension, delay)
Entropy[i] = shannonNormalized(distributions[,i])
Complexity[i] = Ccomplexity(distributions[,i])
}
Shapes <- c(8,15,16,17)
Entropy.Complexity <- data.frame(Entropy, Complexity, Shapes[type], rainbow_colors)
Entropy.Complexity
}
cotas <- function(dimension){
c1x = readingMPR(dimension,1)
c1y = readingMPR(dimension,2)
c2x = readingMPR(dimension,3)
c2y = readingMPR(dimension,4)
p = qplot(xlab=expression(H), ylab=expression(C)) +
theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c2x, y=c2y), size=2, alpha=.5) +
geom_line(aes(x=c1x, c1y), size=2, alpha=.5)
return(p)
}
#Função geradora do Plano entropia complexidade
HCPlane <- function(p, Entropy.Complexity, dimension){
p = p + geom_point(aes(x = Entropy.Complexity$Entropy, y = Entropy.Complexity$Complexity),
shape = Entropy.Complexity$Shape, color = Entropy.Complexity$rainbow_colors,
size = 3)
return(p)
}
#Variáveis globais
n <- 10^4
dimension <- 6
delay <- 1
type <- rep(0,9) #Identificará que tipo de série estamos tratando (f^-k, mapa logistico...)
#f^-k com k: 0, 0.5, 1, 1.5, 2, 3
set.seed(seed = 1234567890, kind = "Mersenne-Twister")
x <- rnorm(n)
x <- x - mean(x)
pp <- planFFT(n)
y <- FFT(x, plan=pp)
k <- c(0, .5, 1, 1.5, 2, 2.5, 3)
series_fk <- matrix(nrow = n, ncol = length(k))
i <- 1
ii <- 1
for(kk in k) {
series_fk[,i] <- series_generator_fk(pp, y, n, kk)
type[ii] <- 1
i <- i + 1
ii <- ii + 1
}
#Mapa logístico: r= 4, 3.6 e x_0 = 0.1
r <- c(3.6,4)
i <- 1
x_0 <- 0.1
series_map <- matrix(nrow = n, ncol = length(r))
d2 <- matrix(nrow = factorial(dimension), ncol = length(r))
for(rr in r){
series_map[,i] <- series_generator_map(rr,x_0,n)
type[ii] <- 2
i <- i + 1
ii <- ii + 1
}
x <- seq(0, 2*pi, length.out=n)
#Sequência monotônica crescente log(x + .1)
series_monotonic <- log(x + 0.1)
type[ii] <- 3
ii <- ii + 1
#Sequência periódica sin(2x) * cos(2x)
series_periodic <- sin(2*x) * cos(2*x)
type[ii] <- 4
series <- data.frame(series_fk,series_map,series_monotonic,series_periodic)
#Gerando os gráficos
subx <- 4500:5500
subx1 <- 4700:4900
subx2 <- 1:100*100
#a = series_fk[subx,1] == series_fk[subx,2]
#print(length(a[a==TRUE]))
#Calcula os valores de entropia e complexidade
rainbow_colors <- palette(rainbow(11))
Entropy.Complexity <- Entropy.complexity.values(series, dimension, delay, type, rainbow_colors)
require(fftw)
require(ggplot2)
require(ggthemes)
require(ggpubr)
require(reshape2)
require(ggrepel)
require(grid)
require(gridExtra)
source('auxFunctions.R')
#Função geradora da série f^⁻k
series_generator_fk <- function(pp, y, n, k){
Series <- vector(mode="numeric")
filtro <- (1:n)^-(k/2)
filtro <- filtro / sum(filtro)
y1 <- y * filtro
x1 <- IFFT(y1, plan=pp)
Series <- c(Re(x1))
Series
}
#Função geradora do mapa logístico
series_generator_map <- function(r, x_0, n){
Series <- vector(mode="numeric",length = n)
Series[1] <- x_0
for(i in c(2:n)){
Series[i] <- r*Series[i-1]*(1 - Series[i-1])
}
Series
}
Entropy.complexity.values <- function(series, dimension, delay, type, rainbow_colors){
Complexity <- Entropy <- rep(0,dim(series)[2])
distributions <- matrix(nrow = factorial(dimension), ncol = dim(series)[2])
for(i in c(1:dim(series)[2])){
distributions[,i] = distribution(series[,i], dimension, delay)
Entropy[i] = shannonNormalized(distributions[,i])
Complexity[i] = Ccomplexity(distributions[,i])
}
Shapes <- c(8,15,16,17)
Entropy.Complexity <- data.frame(Entropy, Complexity, Shapes[type], rainbow_colors)
Entropy.Complexity
}
cotas <- function(dimension){
c1x = readingMPR(dimension,1)
c1y = readingMPR(dimension,2)
c2x = readingMPR(dimension,3)
c2y = readingMPR(dimension,4)
p = qplot(xlab=expression(H), ylab=expression(C)) +
theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c2x, y=c2y), size=2, alpha=.5) +
geom_line(aes(x=c1x, c1y), size=2, alpha=.5)
return(p)
}
#Função geradora do Plano entropia complexidade
HCPlane <- function(p, Entropy.Complexity, dimension){
p = p + geom_point(aes(x = Entropy.Complexity$Entropy, y = Entropy.Complexity$Complexity),
shape = Entropy.Complexity$Shape, color = Entropy.Complexity$rainbow_colors,
size = 3)
return(p)
}
#Variáveis globais
n <- 10^4
dimension <- 6
delay <- 1
type <- rep(0,9) #Identificará que tipo de série estamos tratando (f^-k, mapa logistico...)
#f^-k com k: 0, 0.5, 1, 1.5, 2, 3
set.seed(seed = 1234567890, kind = "Mersenne-Twister")
x <- rnorm(n)
x <- x - mean(x)
pp <- planFFT(n)
y <- FFT(x, plan=pp)
k <- c(0, .5, 1, 1.5, 2, 2.5, 3)
series_fk <- matrix(nrow = n, ncol = length(k))
i <- 1
ii <- 1
for(kk in k) {
series_fk[,i] <- series_generator_fk(pp, y, n, kk)
type[ii] <- 1
i <- i + 1
ii <- ii + 1
}
#Mapa logístico: r= 4, 3.6 e x_0 = 0.1
r <- c(3.6,4)
i <- 1
x_0 <- 0.1
series_map <- matrix(nrow = n, ncol = length(r))
d2 <- matrix(nrow = factorial(dimension), ncol = length(r))
for(rr in r){
series_map[,i] <- series_generator_map(rr,x_0,n)
type[ii] <- 2
i <- i + 1
ii <- ii + 1
}
x <- seq(0, 2*pi, length.out=n)
#Sequência monotônica crescente log(x + .1)
series_monotonic <- log(x + 0.1)
type[ii] <- 3
ii <- ii + 1
#Sequência periódica sin(2x) * cos(2x)
series_periodic <- sin(2*x) * cos(2*x)
type[ii] <- 4
series <- data.frame(series_fk,series_map,series_monotonic,series_periodic)
#Gerando os gráficos
subx <- 4500:5500
subx1 <- 4700:4900
subx2 <- 1:100*100
#a = series_fk[subx,1] == series_fk[subx,2]
#print(length(a[a==TRUE]))
#Calcula os valores de entropia e complexidade
rainbow_colors <- palette(rainbow(11))
Entropy.Complexity <- Entropy.complexity.values(series, dimension, delay, type, rainbow_colors)
require(fftw)
require(ggplot2)
require(ggthemes)
require(ggpubr)
require(reshape2)
require(ggrepel)
require(grid)
require(gridExtra)
source('auxFunctions.R')
setwd("/home/eduarda/Documents/Time_series_analysis_R/Code/R/HCPlane")
require(fftw)
require(ggplot2)
require(ggthemes)
require(ggpubr)
require(reshape2)
require(ggrepel)
require(grid)
require(gridExtra)
source('auxFunctions.R')
require(fftw)
require(ggplot2)
require(ggthemes)
require(ggpubr)
require(reshape2)
require(ggrepel)
require(grid)
require(gridExtra)
source('auxFunctions.R')
#Função geradora da série f^⁻k
series_generator_fk <- function(pp, y, n, k){
Series <- vector(mode="numeric")
filtro <- (1:n)^-(k/2)
filtro <- filtro / sum(filtro)
y1 <- y * filtro
x1 <- IFFT(y1, plan=pp)
Series <- c(Re(x1))
Series
}
#Função geradora do mapa logístico
series_generator_map <- function(r, x_0, n){
Series <- vector(mode="numeric",length = n)
Series[1] <- x_0
for(i in c(2:n)){
Series[i] <- r*Series[i-1]*(1 - Series[i-1])
}
Series
}
Entropy.complexity.values <- function(series, dimension, delay, type, rainbow_colors){
Complexity <- Entropy <- rep(0,dim(series)[2])
distributions <- matrix(nrow = factorial(dimension), ncol = dim(series)[2])
for(i in c(1:dim(series)[2])){
distributions[,i] = distribution(series[,i], dimension, delay)
Entropy[i] = shannonNormalized(distributions[,i])
Complexity[i] = Ccomplexity(distributions[,i])
}
Shapes <- c(8,15,16,17)
Entropy.Complexity <- data.frame(Entropy, Complexity, Shapes[type], rainbow_colors)
Entropy.Complexity
}
cotas <- function(dimension){
c1x = readingMPR(dimension,1)
c1y = readingMPR(dimension,2)
c2x = readingMPR(dimension,3)
c2y = readingMPR(dimension,4)
p = qplot(xlab=expression(H), ylab=expression(C)) +
theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c2x, y=c2y), size=2, alpha=.5) +
geom_line(aes(x=c1x, c1y), size=2, alpha=.5)
return(p)
}
#Função geradora do Plano entropia complexidade
HCPlane <- function(p, Entropy.Complexity, dimension){
p = p + geom_point(aes(x = Entropy.Complexity$Entropy, y = Entropy.Complexity$Complexity),
shape = Entropy.Complexity$Shape, color = Entropy.Complexity$rainbow_colors,
size = 3)
return(p)
}
#Variáveis globais
n <- 10^4
dimension <- 6
delay <- 1
type <- rep(0,9) #Identificará que tipo de série estamos tratando (f^-k, mapa logistico...)
#f^-k com k: 0, 0.5, 1, 1.5, 2, 3
set.seed(seed = 1234567890, kind = "Mersenne-Twister")
x <- rnorm(n)
x <- x - mean(x)
pp <- planFFT(n)
y <- FFT(x, plan=pp)
k <- c(0, .5, 1, 1.5, 2, 2.5, 3)
series_fk <- matrix(nrow = n, ncol = length(k))
i <- 1
ii <- 1
for(kk in k) {
series_fk[,i] <- series_generator_fk(pp, y, n, kk)
type[ii] <- 1
i <- i + 1
ii <- ii + 1
}
#Mapa logístico: r= 4, 3.6 e x_0 = 0.1
r <- c(3.6,4)
i <- 1
x_0 <- 0.1
series_map <- matrix(nrow = n, ncol = length(r))
d2 <- matrix(nrow = factorial(dimension), ncol = length(r))
for(rr in r){
series_map[,i] <- series_generator_map(rr,x_0,n)
type[ii] <- 2
i <- i + 1
ii <- ii + 1
}
x <- seq(0, 2*pi, length.out=n)
#Sequência monotônica crescente log(x + .1)
series_monotonic <- log(x + 0.1)
type[ii] <- 3
ii <- ii + 1
#Sequência periódica sin(2x) * cos(2x)
series_periodic <- sin(2*x) * cos(2*x)
type[ii] <- 4
series <- data.frame(series_fk,series_map,series_monotonic,series_periodic)
#Gerando os gráficos
subx <- 4500:5500
subx1 <- 4700:4900
subx2 <- 1:100*100
#a = series_fk[subx,1] == series_fk[subx,2]
#print(length(a[a==TRUE]))
#Calcula os valores de entropia e complexidade
rainbow_colors <- palette(rainbow(11))
Entropy.Complexity <- Entropy.complexity.values(series, dimension, delay, type, rainbow_colors)
#Plota o gráfico HCPlane
p <- cotas(dimension)
pHC <- HCPlane(p, Entropy.Complexity, dimension)
p0 <- qplot(x=subx, y=series_fk[subx,1], geom="line", color=I(rainbow_colors[1]), xlab="n", ylab="") +
ggtitle("White Noise") + theme(plot.title = element_text(hjust=0.5))
p05 <- qplot(x=subx, y=series_fk[subx,2], geom="line", xlab="n", ylab="", color=I(rainbow_colors[2])) +
ggtitle(expression(f^{-1/2})) + theme(plot.title = element_text(hjust=0.5))
p1 <- qplot(x=subx, y=series_fk[subx,3], geom="line", xlab="n", ylab="", color=I(rainbow_colors[3])) +
ggtitle(expression(f^{-1})) + theme(plot.title = element_text(hjust=0.5))
p15 <- qplot(x=subx, y=series_fk[subx,4], geom="line", xlab="n", ylab="", color=I(rainbow_colors[4])) +
ggtitle(expression(f^{-3/2})) + theme(plot.title = element_text(hjust=0.5))
p2 <- qplot(x=subx, y=series_fk[subx,5], geom="line", xlab="n", ylab="", color=I(rainbow_colors[5])) +
ggtitle(expression(f^{-2})) + theme(plot.title = element_text(hjust=0.5))
p25 <- qplot(x=subx, y=series_fk[subx,6], geom="line", xlab="n", ylab="", color=I(rainbow_colors[6])) +
ggtitle(expression(f^{-5/2})) + theme(plot.title = element_text(hjust=0.5))
p3 <- qplot(x=subx, y=series_fk[subx,7], geom="line", xlab="n", ylab="", color=I(rainbow_colors[7])) +
ggtitle(expression(f^{-3})) + theme(plot.title = element_text(hjust=0.5))
plogistic36 <- qplot(x=subx1, y=series_map[subx1,1], geom="line", xlab="n", ylab="", color=I(rainbow_colors[8])) +
ggtitle("Logistic Map r = 3.6") + theme(plot.title = element_text(hjust=0.5))
plogistic4 <- qplot(x=subx1, y=series_map[subx1,2], geom="line" ,xlab="n", ylab="", color=I(rainbow_colors[9])) +
ggtitle("Logistic Map r = 4") + theme(plot.title = element_text(hjust=0.5))
plog <- qplot(x=subx2, y=series_monotonic[subx2], geom="line", xlab="x", ylab="", color=I(rainbow_colors[10])) +
ggtitle(expression(paste("log(", x + .1, ")"))) +
theme(plot.title = element_text(hjust=0.5))
psincos <- qplot(x=subx2, y=series_periodic[subx2], geom="line", xlab="x", ylab="", color=I(rainbow_colors[11])) +
ggtitle(expression(paste("sin(", 2 * x, ")", "cos(", 2 * x, ")"))) +
theme(plot.title = element_text(hjust=0.5))
#Plotando todos os gráficos gerados em um grid
grid.newpage()
pushViewport(viewport(layout = grid.layout(5, 4)))
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
print(pHC, vp = vplayout(2:4, 1:3))
print(plogistic36, vp = vplayout(1, 1))
print(plogistic4, vp = vplayout(1, 2))
print(p3, vp = vplayout(1, 3))
print(p25, vp = vplayout(1, 4))
print(p2, vp = vplayout(2, 4))
print(p15, vp = vplayout(3, 4))
print(p1, vp = vplayout(4, 4))
print(plog, vp = vplayout(5, 1))
print(psincos, vp = vplayout(5, 2))
print(p0, vp = vplayout(5, 3))
print(p05, vp = vplayout(5, 4))
p <- cotas(dimension)
pHC <- HCPlane(p, Entropy.Complexity, dimension)
print(pHC)
require(simcausal)
#Função geradora do mapa logístico
series_generator_map <- function(r, x_0, n, n_series, init){
Series <- matrix(nrow = n_series, ncol = n)
a <- x_0
for(i in c(2:init)){
aa <- r*a*(1 - a)
a <- aa
}
x_0 <- r*a*(1 - a)
for(i in c(1:n_series)){
Series[i,1] <- x_0
for(j in c(2:n)){
Series[i,j] <- r*Series[i,j-1]*(1 - Series[i,j-1])
}
x_0 <- r*Series[i,n]*(1 - Series[i,n])
}
return(Series)
}
atack <- function(n_series,series,p,n){
Series.to.analysis <- matrix(nrow = n_series + 1, ncol = n)
for(j in c(1:n_series)){
x <- series
indicator <- rbern(n,p)
for(i in c(2:n)){
if(indicator[i]==1){
x[i] = x[i-1]
}
}
Series.to.analysis[j,] <- x
}
Series.to.analysis[n_series+1,] <- series
Series.to.analysis
}
cotas <- function(dimension){
c1x = readingMPR(dimension,1)
c1y = readingMPR(dimension,2)
c2x = readingMPR(dimension,3)
c2y = readingMPR(dimension,4)
p = qplot(xlab=expression(H), ylab=expression(C)) +
theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c2x, y=c2y), size=2, alpha=.5) +
geom_line(aes(x=c1x, c1y), size=2, alpha=.5)
return(p)
}
HCPlane <- function(p, Entropy.Complexity, dimension){
p = p + geom_point(aes(x = Entropy.Complexity$Entropy, y = Entropy.Complexity$Complexity),
size = 3)
return(p)
}
Entropy.complexity.values <- function(Series.to.analysis, dimension, delay, n_series){
prob = matrix(nrow = 4*n_series, ncol = factorial(dimension))
Complexity = Entropy = rep(0,(4*n_series))
j = i = 1
while(j <= (4*n_series)){
prob[j,] <- completeCase(Series.to.analysis[i,], dimension, delay) #Blue
Entropy[j] <- shannonNormalized(prob[j,])
Complexity[j] <- Ccomplexity(prob[j,])
prob[j + 1,] <- timeOrdered(Series.to.analysis[i,], dimension, delay) #Green
Entropy[j + 1] <- shannonNormalized(prob[j + 1,])
Complexity[j + 1] <- Ccomplexity(prob[j + 1,])
prob[j + 2,] <- randomImputation(Series.to.analysis[i,], dimension, delay) #Orange
Entropy[j + 2] <- shannonNormalized(prob[j + 2,])
Complexity[j + 2] <- Ccomplexity(prob[j + 2,])
prob[j + 3,] <- dataDriven(Series.to.analysis[i,], dimension, delay) #Wine
Entropy[j + 3] <- shannonNormalized(prob[j + 3,])
Complexity[j + 3] <- Ccomplexity(prob[j + 3,])
j = j + 4
i = i + 1
}
Entropy.Complexity <- data.frame(Entropy, Complexity)
Entropy.Complexity
}
require(simcausal)
#Função geradora do mapa logístico
series_generator_map <- function(r, x_0, n, n_series, init){
Series <- matrix(nrow = n_series, ncol = n)
a <- x_0
for(i in c(2:init)){
aa <- r*a*(1 - a)
a <- aa
}
x_0 <- r*a*(1 - a)
for(i in c(1:n_series)){
Series[i,1] <- x_0
for(j in c(2:n)){
Series[i,j] <- r*Series[i,j-1]*(1 - Series[i,j-1])
}
x_0 <- r*Series[i,n]*(1 - Series[i,n])
}
return(Series)
}
atack <- function(n_series,series,p,n){
Series.to.analysis <- matrix(nrow = n_series + 1, ncol = n)
for(j in c(1:n_series)){
x <- series
indicator <- rbern(n,p)
for(i in c(2:n)){
if(indicator[i]==1){
x[i] = x[i-1]
}
}
Series.to.analysis[j,] <- x
}
Series.to.analysis[n_series+1,] <- series
Series.to.analysis
}
cotas <- function(dimension){
c1x = readingMPR(dimension,1)
c1y = readingMPR(dimension,2)
c2x = readingMPR(dimension,3)
c2y = readingMPR(dimension,4)
p = qplot(xlab=expression(H), ylab=expression(C)) +
theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c2x, y=c2y), size=2, alpha=.5) +
geom_line(aes(x=c1x, c1y), size=2, alpha=.5)
return(p)
}
HCPlane <- function(p, Entropy.Complexity, dimension){
p = p + geom_point(aes(x = Entropy.Complexity$Entropy, y = Entropy.Complexity$Complexity),
size = 3)
return(p)
}
Entropy.complexity.values <- function(Series.to.analysis, dimension, delay, n_series){
prob = matrix(nrow = 4*n_series, ncol = factorial(dimension))
Complexity = Entropy = rep(0,(4*n_series))
j = i = 1
while(j <= (4*n_series)){
prob[j,] <- completeCase(Series.to.analysis[i,], dimension, delay) #Blue
Entropy[j] <- shannonNormalized(prob[j,])
Complexity[j] <- Ccomplexity(prob[j,])
prob[j + 1,] <- timeOrdered(Series.to.analysis[i,], dimension, delay) #Green
Entropy[j + 1] <- shannonNormalized(prob[j + 1,])
Complexity[j + 1] <- Ccomplexity(prob[j + 1,])
prob[j + 2,] <- randomImputation(Series.to.analysis[i,], dimension, delay) #Orange
Entropy[j + 2] <- shannonNormalized(prob[j + 2,])
Complexity[j + 2] <- Ccomplexity(prob[j + 2,])
prob[j + 3,] <- dataDriven(Series.to.analysis[i,], dimension, delay) #Wine
Entropy[j + 3] <- shannonNormalized(prob[j + 3,])
Complexity[j + 3] <- Ccomplexity(prob[j + 3,])
j = j + 4
i = i + 1
}
Entropy.Complexity <- data.frame(Entropy, Complexity)
Entropy.Complexity
}
p <- cotas(dimension)
pHC <- HCPlane(p, Entropy.Complexity, dimension)
print(pHC)
Entropy.Complexity
View(Entropy.Complexity)
write.csv(Entropy.Complexity, file = "Entropy.Complexity.csv")
